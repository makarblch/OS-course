## Кулишенко Макар Андреевич. Домашнее задание 9
### Операционные системы.

***Работа выполнена на 10 баллов***

Условие:

Реализовать для родительского и дочернего процесса двухстороннюю связь с использованием только одного неименованного канала (pipe) и циклической организацией обмена посредством семафора. При этом канал должен быть постоянно открытым. Обмен должен завершаться после поочередной передачи в каждую сторону по десять сообщений. По завершении обмена обеспечить корректное закрытие каналов и удаление семафора.

Вместо десяти обменов организовать поочередный обмен, завершающийся посылкой сигнала прерывания с клавиатуры родительскому или дочернему процессу. При этом оба процесса должны корректно завершить работу с закрытием канала и удалением семафора.

Решение:

Код находится в файле **code.c**.

Идея:
Напишем для родительского и дочернего потока методы, которые эмулируют чтение и запись.

```
char message[100];

int i = 1;
// Дочерний семафор
struct sembuf buffer = {
    .sem_num = 0,
    .sem_op  = 0,
    .sem_flg = 0,
};

while (true) {

    // Закрываем семафор для родительского процесса
    buffer.sem_op = -1;

    // Открываем семафор для дочернего процесса
    if (semop(sem_id, &buffer, 1) == -1) {
        perror("semop");
        return EXIT_FAILURE;
    }

    // Читаем из пайпа
    const ssize_t bytes_read = read(fd[0], message, sizeof(message));
    if (bytes_read < 0) {
        perror("read");
        return EXIT_FAILURE;
    }

    printf("Дочерний процесс прочитал: %s\n", message);

    const int bytes_written = sprintf(message, "Сообщение: %u от дочернего[pid=%d] к родительскому[pid=%d]", i, child_pid, parent_pid);
    if (bytes_written < 0) {
        perror("sprintf");
        return EXIT_FAILURE;
    }

    if (write(fd[1], message, bytes_written + 1) < 0) {
        perror("write");
        return EXIT_FAILURE;
    }

    // Открываем семафор для родительского процесса
    buffer.sem_op = 1;
    if (semop(sem_id, &buffer, 1) == -1) {
        perror("semop");
        return EXIT_FAILURE;
    }

    ++i;

    sleep(SLEEP_SECONDS);
}
```
Что тут происходит?

- объявляем буффер для записи
- объявляем семафор, который будет использован для синхронизации работы дочернего и родительского процесса с дочерней стороны
- в цикле до тех пор, пока не будет отправлен сигнал прерывания, продолжать читать и передавать другому процессу сообщения
- после передачи сообщения процесс засыпает на 2 секунды

Эта функция применяется для обоих процессов. 

В основной программе создаем обработчик сигнала, создаем и настраиваем семафор и пайп, затем делаем форк и в зависимости от pid вызываем необходимую функцию.

Пример работы:

![alt text](image.png)

Спасибо за внимание!